import { create } from 'zustand';
import type { User } from '../types';
import { tokenManager } from '../lib/api';

interface SMTPCredentials {
  email: string;
  password: string;
  imap_server: string;
  imap_port: number;
  smtp_server: string;
  smtp_port: number;
  use_ssl: boolean;
}

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  gmailConnected: boolean;
  outlookConnected: boolean;
  smtpConnected: boolean;
  emailProvider: string | null;

  // Actions
  login: (email: string, password: string) => Promise<void>;
  register: (name: string, email: string, password: string, autoGeneratedPassword?: boolean) => Promise<void>;
  requestMagicLink: (email: string) => Promise<void>;
  verifyMagicLink: (token: string) => Promise<void>;
  logout: () => void;
  connectGmail: () => void;
  disconnectGmail: () => void;
  handleGmailCallback: (code: string) => Promise<void>;
  connectOutlook: () => void;
  disconnectOutlook: () => Promise<void>;
  handleOutlookCallback: (code: string, state: string) => Promise<void>;
  connectSMTP: (credentials: SMTPCredentials) => Promise<void>;
  disconnectSMTP: () => Promise<void>;
  clearError: () => void;
  checkAuth: () => Promise<void>;
  completeOnboarding: () => Promise<void>;
  setPassword: (password: string) => Promise<void>;
}

const API_BASE = import.meta.env.VITE_API_BASE_URL || (
  typeof window !== 'undefined' && window.location.hostname !== 'localhost'
    ? 'https://backend-api-production-9c10.up.railway.app'
    : 'http://localhost:8955'
);

export const useAuthStore = create<AuthState>((set, get) => ({
  user: null,
  isAuthenticated: false,
  isLoading: false,
  error: null,
  gmailConnected: false,
  outlookConnected: false,
  smtpConnected: false,
  emailProvider: null,

      login: async (email: string, password: string) => {
        set({ isLoading: true, error: null });
        try {
          const response = await fetch(`${API_BASE}/api/auth/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password }),
            credentials: 'include',
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || 'Login failed');
          }

          const { user, gmailConnected, access_token } = await response.json();
          if (access_token) {
            tokenManager.set(access_token);
          }
          set({
            user,
            isAuthenticated: true,
            isLoading: false,
            gmailConnected: gmailConnected || false,
          });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'Login failed',
            isLoading: false
          });
          throw error;
        }
      },

      register: async (name: string, email: string, password: string, autoGeneratedPassword: boolean = false) => {
        set({ isLoading: true, error: null });
        try {
          const response = await fetch(`${API_BASE}/api/auth/register`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, email, password, auto_generated_password: autoGeneratedPassword }),
            credentials: 'include',
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || errorData.detail || errorData.message || 'Registration failed');
          }

          const { user, access_token } = await response.json();
          if (access_token) {
            tokenManager.set(access_token);
          }
          set({
            user,
            isAuthenticated: true,
            isLoading: false,
            gmailConnected: false,
          });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'Registration failed',
            isLoading: false
          });
          throw error;
        }
      },

      requestMagicLink: async (email: string) => {
        set({ isLoading: true, error: null });
        try {
          const response = await fetch(`${API_BASE}/api/auth/magic-link`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email }),
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || 'Failed to send magic link');
          }

          set({ isLoading: false });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'Failed to send magic link',
            isLoading: false
          });
          throw error;
        }
      },

      verifyMagicLink: async (token: string): Promise<void> => {
        set({ isLoading: true, error: null });
        try {
          const response = await fetch(`${API_BASE}/api/auth/verify`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ token }),
            credentials: 'include',
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || 'Invalid or expired link');
          }

          const { user, gmailConnected, access_token } = await response.json();
          if (access_token) {
            tokenManager.set(access_token);
          }
          set({
            user,
            isAuthenticated: true,
            isLoading: false,
            gmailConnected: gmailConnected || false,
          });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'Verification failed',
            isLoading: false
          });
          throw error;
        }
      },

      logout: (): void => {
        fetch(`${API_BASE}/api/auth/logout`, {
          method: 'POST',
          credentials: 'include',
        }).catch((error) => {
          // Log error but don't block logout
          console.error('Logout API call failed:', error);
        });

        tokenManager.remove();
        set({
          user: null,
          isAuthenticated: false,
          gmailConnected: false,
          error: null
        });
      },

      connectGmail: () => {
        // Redirect to Gmail OAuth
        window.location.href = `${API_BASE}/api/auth/gmail`;
      },

      disconnectGmail: async (): Promise<void> => {
        try {
          const response = await fetch(`${API_BASE}/api/auth/gmail/disconnect`, {
            method: 'POST',
            credentials: 'include',
          });

          if (response.ok) {
            set({ gmailConnected: false });
          }
        } catch (error) {
          console.error('Failed to disconnect Gmail:', error);
        }
      },

      handleGmailCallback: async (code: string): Promise<void> => {
        set({ isLoading: true, error: null });
        try {
          const response = await fetch(`${API_BASE}/api/auth/gmail/callback?code=${code}`, {
            method: 'GET',
            credentials: 'include',
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || 'Gmail connection failed');
          }

          set({ gmailConnected: true, emailProvider: 'gmail', isLoading: false });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'Gmail connection failed',
            isLoading: false
          });
          throw error;
        }
      },

      connectOutlook: () => {
        // Get auth URL from backend and redirect
        const token = tokenManager.get();
        const redirectUri = encodeURIComponent(`${window.location.origin}/auth/outlook/callback`);
        window.location.href = `${API_BASE}/api/auth/outlook?redirect_uri=${redirectUri}`;
      },

      disconnectOutlook: async (): Promise<void> => {
        try {
          const token = tokenManager.get();
          const response = await fetch(`${API_BASE}/api/auth/outlook`, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${token}`,
            },
            credentials: 'include',
          });

          if (response.ok) {
            set({ outlookConnected: false, emailProvider: null });
          }
        } catch (error) {
          console.error('Failed to disconnect Outlook:', error);
        }
      },

      handleOutlookCallback: async (code: string, state: string): Promise<void> => {
        set({ isLoading: true, error: null });
        try {
          const redirectUri = encodeURIComponent(`${window.location.origin}/auth/outlook/callback`);
          const response = await fetch(
            `${API_BASE}/api/auth/outlook/callback?code=${encodeURIComponent(code)}&state=${encodeURIComponent(state)}&redirect_uri=${redirectUri}`,
            {
              method: 'GET',
              credentials: 'include',
            }
          );

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Outlook connection failed');
          }

          set({ outlookConnected: true, emailProvider: 'outlook', isLoading: false });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'Outlook connection failed',
            isLoading: false
          });
          throw error;
        }
      },

      connectSMTP: async (credentials: SMTPCredentials): Promise<void> => {
        set({ isLoading: true, error: null });
        try {
          const token = tokenManager.get();
          const response = await fetch(`${API_BASE}/api/auth/smtp`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`,
            },
            body: JSON.stringify(credentials),
            credentials: 'include',
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'SMTP connection failed');
          }

          set({ smtpConnected: true, emailProvider: 'smtp', isLoading: false });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'SMTP connection failed',
            isLoading: false
          });
          throw error;
        }
      },

      disconnectSMTP: async (): Promise<void> => {
        try {
          const token = tokenManager.get();
          const response = await fetch(`${API_BASE}/api/auth/smtp`, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${token}`,
            },
            credentials: 'include',
          });

          if (response.ok) {
            set({ smtpConnected: false, emailProvider: null });
          }
        } catch (error) {
          console.error('Failed to disconnect SMTP:', error);
        }
      },

      clearError: () => set({ error: null }),

  checkAuth: async (): Promise<void> => {
    set({ isLoading: true });
    const token = tokenManager.get();
    if (!token) {
      set({
        user: null,
        isAuthenticated: false,
        gmailConnected: false,
        outlookConnected: false,
        smtpConnected: false,
        emailProvider: null,
        isLoading: false
      });
      return;
    }
    try {
      const response = await fetch(`${API_BASE}/api/auth/me`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
        },
        credentials: 'include',
      });

      if (response.ok) {
        const { user, gmailConnected, outlookConnected, smtpConnected, emailProvider } = await response.json();
        set({
          user,
          isAuthenticated: true,
          gmailConnected: gmailConnected || false,
          outlookConnected: outlookConnected || false,
          smtpConnected: smtpConnected || false,
          emailProvider: emailProvider || null,
          isLoading: false
        });
      } else {
        tokenManager.remove();
        set({
          user: null,
          isAuthenticated: false,
          gmailConnected: false,
          outlookConnected: false,
          smtpConnected: false,
          emailProvider: null,
          isLoading: false
        });
      }
    } catch (error) {
      set({
        user: null,
        isAuthenticated: false,
        gmailConnected: false,
        outlookConnected: false,
        smtpConnected: false,
        emailProvider: null,
        isLoading: false
      });
    }
  },

  completeOnboarding: async (): Promise<void> => {
    try {
      const token = tokenManager.get();
      const response = await fetch(`${API_BASE}/api/auth/onboarding/complete`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({ completed: true }),
        credentials: 'include',
      });

      if (response.ok) {
        // Update local user state to reflect onboarding completion
        const currentUser = get().user;
        if (currentUser) {
          set({
            user: { ...currentUser, onboarding_completed: true }
          });
        }
      }
    } catch (error) {
      console.error('Failed to complete onboarding:', error);
    }
  },

  setPassword: async (password: string): Promise<void> => {
    try {
      const token = tokenManager.get();
      const response = await fetch(`${API_BASE}/api/auth/set-password`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({ password }),
        credentials: 'include',
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || errorData.detail || errorData.message || 'Failed to set password');
      }

      // Update local user state to reflect password has been set
      const currentUser = get().user;
      if (currentUser) {
        set({
          user: { ...currentUser, needs_password_setup: false }
        });
      }
    } catch (error) {
      console.error('Failed to set password:', error);
      throw error;
    }
  },
}));
